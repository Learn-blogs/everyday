## 第8章 函数

### 函数的定义

+ 函数名称标识符
+ 一对圆括号
+ 一对花括号, 其中包含0或者多条JavaScript语句

函数声明语句"被提前"到外部脚本或外部函数作用域的顶部, 所以可以被在它定义之前的代码说调用. 

而表达式定义的函数就另当别论了, 为了调用一个函数, 必须要能引用它, 而要使用一个以表达式方式定义的函数之前, 必须把它赋值给一个变量. 变量的声明提前了, 但给变量的赋值是不会提前的, 所以, 以表达式定义的函数在定义的函数之前是无法调用的. 

### 函数调用 

**调用JavaScript函数的4中方式**: 

+ 作为函数
+ 作为方法
+ 作为构造函数
+ 通过它们的call()和apply()方法间接调用

函数调用一定有一个返回值, 如果代码没有指定, 这返回undefined
根据es3和非严格模式的es5下对函数调用的规定, 调用上下文(this的值)是全局对象. 然而, 在es5的严格模式下, 调用上下文是undefined. 

以函数形式调用的函数通常不使用this关键字. 不过, 'this'可以用来判断当前是否是严格模式: 

```javascript
var strict = (function(){ return !this;}());
```

### 方法调用

方法链

**this**是关键字, 不是变量, 也不是属性名, JavaScript的语法不允许给this复制 
和变量不同, 关键字this没有作用域的限制, 嵌套的函数不会从调用它的函数中继承this. 如果嵌套函数作为方法调用, 其**this**的值指向调用它的对象. 如果嵌套函数作为函数调用, 其this值不是全局对象(非严格模式下)就是undefined(严格模式). 如果你想访问这个外部的函数this, 需要将this的值保存到一个变量中(通常是self)

### 构造函数调用

构造函数通常不使用return关键字, 它们通常初始化新对象, 当构造函数的函数体执行完毕时, 它会显式返回. 

如果构造函数显式使用return语句返回一个对象, 那么调用表达式的值就是这个对象. 

如果构造函数使用return语句但没有指定返回值, 或者返回一个原始值, 那么这时将忽略返回值, 直接使用这个新对象作为调用结构 

### 函数的实参和形参

arguments类数组对象, 包含以数字为索引的一组元素以及length属性, 
将arguments转换为一个数组对象: 

```javascript
Array.prototype.slice.call(arguments, 0); 
```

在非严格模式下, 当一个函数包含若干个形参, 实参对象的数组元素是函数形参对象参数的别名, 实参对象中以数字索引, 并且形参名称可以认为是相同变量的不同命名. 通过实参名字来修改实参值的话, 通过arguments[]数组也可以获取到更改后的值.

```javascript
function f(x){
    console.log(x); // 输出实参的初始值
    arguments[0] = null; // 修改实参数组的元素同样会修改x的值
    console.log(x); // output "null"
}
```

数组对象(实参对象)包含一个非同寻常的特性. 如果实参对象是一个普通数组的话, 上面例子中第二条console.log(x)语句的结果绝对不会是null. 在这个例子中, arguments[0]和x指代同一个值, 修改其中一个值会影响到另一个. 

在es5中移除了实参对象的这个特殊特性. 

### callee和caller属性

除了数组元素, 实参对象还定义了callee和caller属性, 在es5的严格模式下, 对这两个属性的读写操作都会产生一个类型错误. 在非严格模式下, ECMAScript标准规范规定callee属性指代当前正在执行的函数. caller是非标准的, 但大多数浏览器都实现了这个属性, 它指代调用当前正在执行的函数的函数, 通过caller属性可以访问调用栈. 

callee属性可以用在匿名函数递归调用自身: 

```javascript
var factorial = function(){
    if( x <= 1) return 1; 
    return x * arguments.callee(x-1);
}
```
### 作为值的函数

函数可以定义, 也可以调用, 这个函数最重要的特性. 在javascript中, 函数还是值, 所以可以讲函数赋值给变量, 存储在对象的属性或数组的元素中, 作为参数传入另外一个函数. 

**自定义函数属性**

```javascript
// 由于函数的声明被提前了, 因此这里可以在函数声明之前给它的成员赋值
uniqueInteger.counter = 0 ;

function uniqueInteger(){
   return uniqueInteger.counter++;  
}
```

下面这个函数factorial()使用自身的属性来缓存上一次的计算结果: 

